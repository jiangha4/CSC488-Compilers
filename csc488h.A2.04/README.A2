CSC488
Assignment 2
Group 4
Group Members:
	Haohan Jiang (g3jiangh)
	Chris Arnold (g3arnold)
	Chandeep Singh (g2singh)
	Maria Yancheva (c2yanche)
	Timo Vink (c4vinkti)

Grammar Design
--------------

1. Recursive production rules

All recursive rules were implemented using left recursion, for example a rule in the reference grammar of the form:

X:	X X, 
	base_case

was transformed to the following in the cup file:

X_multiple 	::= X_multiple X_base
X_base 		::= base_case


2. Expressions and precedence of operators

A separate production rule was specified for each level of operators (as defined on page 3 of the reference grammar). The highest precedence operator (unary -) is specified in the lowest level, and the lowest precedence operator (Boolean | ) is specified in the highest level. Each subsequent level is defined in terms of the previous level. 

Here is an overview of the expression production rules in our grammar:

expression 	// Highest level expression production rule, consists of level 6 productions
exprLvl6	// Level 6 - corresponds to | operator
exprLvl5	// Level 5 - corresponds to & operator
exprLvl4	// Level 4 - corresponds to ! operator
exprLvl3	// Level 3 - corresponds to comparison operators
exprLvl2	// Level 2 - corresponds to + and binary - operators
exprLvl1	// Level 1 - corresponds to * and / operators
exprLvl0	// Level 0 - corresponds to unary - operator
exprAtom	// Lowest level expression production rule, consists of base expressions

The base expressions (i.e., the ones that do not contain operators in the RHS of the production rule) are defined in the exprAtom production rule in the cup grammar, of which all higher level expressions can be composed of. Note, the base expressions which contain 'expression' on their RHS are defined in terms of the highest level of 'expression' (which allows lower precedence operations to be nested within higher precedence operations, e.g. "a = (! b)" ).

Operators of levels 1, 2, 5 and 6 which associate from left to right are implemented using left recursion in the production rule for the corresponding level.

Operators of level 3 which do not associate are implemented without recursion in the production rule for that level.


Testing
-------
Tests folder structure:
All tests can be found under the tests/passing and tests/failing folders. In each of those, there are folders for the types of statements the tests cover (i.e. functions, conditional statements, expressions). Finally in the folders for each statement type, there are relevant tests, each named so that the filename gives a description of the test.

Below is a summary of the tests from each folder (the filenames give a description of each individual tests):

tests/passing
    complex
        -misc. complex tests combining various types of statements together.
        -also includes 5 program written for Assignment 1
    conditional
        -tests different conditional statements (basic if, if else, if elseif else, etc)
    expression
        arithmetic
            simple
                -tests simple arithmetic (add, subtract, divide, multiply)
            compound
                -tests combinations of the above arithmetic
        comparison
            -tests simple comparison statements (>, <, >=, <=, = operators) 
        logical
            simple
                -tests simple logical statements (and or and not operators)
            compound
                -tests combinations of above operators
        mixed
            -tests combinations of all the different expression types (arithmetic + comparison, arithmetic + logical)
    function
        declarations
            -test simple function declarations (with and without params, etc)
        invoke
            -test simple function invokations (with and without params)
        return
            -test return statement parsing
    io
        -test io statements (get, put, etc)
    loops
        -test basic loops, while loops, exit conditions, etc.
    procedure
        -test procedure declarations and calls (with and without params)
    scope
        -test scope parsing (empty, nest scopes)
    variable
        -test declarations of variables of various types, arrays of different types, multi-dimensional arrays, and mixed array bounds
    

For testing, the general idea was to go through each grammar rule for the different sets of statements, and write at least one test case for each. For example, each rule for expressions is covered in the expressions folder, and there are multiple tests for arithmetic, comparison, logical, and mixed type expressions.

For testing precedence, we simply output the parsed statements with brackets put in place, and manually checked to make sure precedence was correct.


[<more about 'failing' tests here]

	
Who Did What
------------

Haohan Jiang - Added grammar for statements.
	       Wrote the complex tests and turned A1 into complex tests.
	       Wrote other simple passing and failing tests. 

CSC488
Assignment 2
Group 4
Group Members:
	Haohan Jiang (g3jiangh)
	Chris Arnold (g3arnold)
	Chandeep Singh (g2singh)
	Maria Yancheva (c2yanche)
	Timo Vink (c4vinkti)

Grammar Design
--------------

1. Recursive production rules

All recursive rules were implemented using left recursion, for example a rule in the reference grammar of the form:

X:	X X, 
	base_case

was transformed to the following in the cup file:

X_multiple 	::= X_multiple X_base
X_base 		::= base_case


2. Expressions and precedence of operators

A separate production rule was specified for each level of operators (as defined on page 3 of the reference grammar). The highest precedence operator (unary -) is specified in the lowest level, and the lowest precedence operator (Boolean | ) is specified in the highest level. Each subsequent level is defined in terms of the previous level. 

Here is an overview of the expression production rules in our grammar:

expression 	// Highest level expression production rule, consists of level 6 productions
exprLvl6	// Level 6 - corresponds to | operator
exprLvl5	// Level 5 - corresponds to & operator
exprLvl4	// Level 4 - corresponds to ! operator
exprLvl3	// Level 3 - corresponds to comparison operators
exprLvl2	// Level 2 - corresponds to + and binary - operators
exprLvl1	// Level 1 - corresponds to * and / operators
exprLvl0	// Level 0 - corresponds to unary - operator
exprAtom	// Lowest level expression production rule, consists of base expressions

The base expressions (i.e., the ones that do not contain operators in the RHS of the production rule) are defined in the exprAtom production rule in the cup grammar, of which all higher level expressions can be composed of. Note, the base expressions which contain 'expression' on their RHS are defined in terms of the highest level of 'expression' (which allows lower precedence operations to be nested within higher precedence operations, e.g. "a = (! b)" ).

Operators of levels 1, 2, 5 and 6 which associate from left to right are implemented using left recursion in the production rule for the corresponding level.

Operators of level 3 which do not associate are implemented without recursion in the production rule for that level.


Testing
-------
Tests' folder structure:
All tests can be found under the tests/passing and tests/failing folders. In each of those, there are folders for the different production rules the tests cover (e.g. functions, conditional statements, expressions, etc). Finally, in the folders for each test type, there are relevant tests, each named so that the filename gives a description of the test (e.g. "declareIntOneDimArray.488"). For a full listing of the tests, see TEST_DESCR.A2

The general idea was to go through each grammar rule in the reference grammar and write at least one test case for each. For example, each rule for expressions is covered in the expressions folder, and there are multiple tests for arithmetic, comparison, logical, and mixed type expressions.

For testing precedence, we used JCup callbacks in the grammar file to output the parsed sentences with parentheses put in place around each terminal symbol, and manually checked to make sure precedence was correct. These callbacks were removed from the submitted grammar to ensure nothing gets displayed when running the batch testing scripts.

Below is a summary of the tests from each folder (as mentioned above, the filenames give a description of each individual test):

tests/passing
    complex
        -misc. complex tests combining various types of production rules together
        -also includes 5 programs written for Assignment 1
    conditional
        -tests different conditional statements (basic if, if else, etc)
    expression
        arithmetic
            simple
                -tests simple arithmetic operators (add, subtract, divide, multiply)
            compound
                -tests combinations of the above arithmetic operators
        comparison
            -tests simple comparison expressions (>, <, >=, <=, = operators) 
        logical
            simple
                -tests simple logical expressions (&, | and ! operators)
            compound
                -tests combinations of above operators
        mixed
            -tests combinations of all the different expression types (arithmetic + comparison, arithmetic + logical, all types of operators + recursive expressions, including yield statement)
    function
        declarations
            -tests simple function declarations (with and without params, etc)
        invoke
            -tests simple function invocations (with and without params)
        return
            -tests return statement parsing
    io
        -tests io statements (get, put)
    loops
        -tests basic loops, while loops, exit conditions, etc.
    procedure
        -tests procedure declarations and calls (with and without params)
    scope
        -tests scope parsing (empty, nested scopes)
    variable
        -tests declarations of variables of various types, arrays of different types, multi-dimensional arrays, and mixed array bounds; assignment of variables and arrays
		

tests/failing
    condition
        - tests malformed conditional statements with various keywords (if, else, then, end) and expressions missing 
    expression
        arithmetic
            - tests malformed arithmetic expressions (add, subtract, divide, multiply) that are missing operands or consecutive operators 
        comparison
            - tests malformed comparison expressions (>, <, >=, <=, =) that are missing operands, contain consecutive operators or chained together expressions inappropriately
        logical
            - tests malformed logical expressions (and, not, or) that are missing operands
        mixed
    function
        - tests malformed functions with various keywords (function, begin, end, the type) and parentheses missing 
    io
        - tests malformed io statements (get and put with missing inputs/outputs)
    loop
        - tests malformed loops with various keywords (exit, when, do, end) and expressions missing 
    procedure
        - tests malformed procedures with the procedure keyword, scope or type missing
    scope
        - tests malformed scopes that are missing keywords (begin, end) in different scope nestings or simply not there at all
    variable
        - tests malformed variable declarations, including missing parentheses, arrays with negative bounds and assigning too many values to the same variable

	
Who Did What
------------

Haohan Jiang (g3jiangh)
- Added grammar for statements.
- Wrote the complex tests and turned A1 into complex tests.
- Wrote other simple passing and failing tests. 

Chris Arnold (g3arnold)
- Wrote function tests.
- Wrote some of the readme.

Chandeep Singh (g2singh)
- Tests & documentation

Maria Yancheva (c2yanche)
- Grammar: added most production rules to grammar; worked on removing recursion ambiguities and implementing precedence rules
- Testing: added tests for mixed expressions (containing operators, yield statement, expression recursion), variables, scope
- Documentation: wrote the grammar design section

Timo Vink (c4vinkti)	
- Grammar: implemented operator precedence rules; refactored code for style; added JCup callbacks to grammar for debugging purposes (to check operator precedence)
- Testing: wrote the batch test running script; added tests for statements, loops, scope, variables, IO, expressions
- Documentation: wrote the test listing script
				
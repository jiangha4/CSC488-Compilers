// Package and import specifications section.

package compiler488.parser;

import java_cup.runtime.*;        // Must always import this.

/* User code components 1: action code components.
 * Code to be used inside the actions triggered when productions are matched.
 * If any common code is needed for more than one action , put it here.
 */
// action code {:
// your code goes HERE
//:};

/* User code components 2: parser code components.
 * Modifications to the default generated parser
 */
parser code {:

    String lastError;

    /** Override the report_error method so it will display the line and
     * column of where the error occurred in the input as well as the
     * reason for the error which is passed into the method in the
     * String 'message'.
     * @param message  error message to print
     * @param info     symbol containing line/column numbers
     */
    public void report_error(String message, Object info)
    {
    String st =  "Error";

        if (info instanceof java_cup.runtime.Symbol)
        {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

        /* s.left is supposed to hold the line number of the error.
         * s.right is supposed to hold the column number.
             * If either is < 0 the parser may have run off the end of the program
             * and a Syntax Error message without line number may be printed.
         */

            if (s.left >= 0)                // Check line number.
        {
                st += " in line " + (s.left + 1);
                if (s.right >= 0)            // Check column number.
                    st += ", column " + (s.right + 1);
        }
            else
               st += " at end of input " ;
           }
        st += ": " + message;
        System.err.println (st);
        lastError = st;
    }

    /** Override the report_fatal_error method to use the report_error method. */
    public void report_fatal_error (String message, Object info)
    {
        report_error (message, info);
    }

:};

/* User code components 3: initialization code.
 * If you want some code to be executed before the parser asks for the first
 * token, add it here.
 */
init with {:
:};

/* User code components 4: scanner specification code.
 * If you need to override the way the parser asks the scanner for the
 * next token, put your preferred method here.  Uncomment the line following
 * this comment, replace the line after that with your code, and uncomment
 * the line after that.
 */
// scan with {:
// your code goes here
// :};

/* Symbol lists section.
 * The names of terminals and non-terminals are not allowed to be CUP
 * reserved words.  These include "code", "action", "parser", "terminal",
 * "non", "nonterminal", "init", "scan", "with", "start", "precedence",
 * "left", "right", "nonassoc", "import", and "package".
 */

// DEFINITIONS for CSC488S Source Language  Winter  2009/2010

// Terminals returned by the scanner with no value attached.
terminal    AND,    OR,    NOT,    TRUE,    FALSE    ;
terminal     BOOLEAN,INTEGER,FUNCTION,PROCEDURE    ;
terminal    BEGIN,    DO,    ELSE,    END,    EXIT    ;
terminal    IF,    RETURN,    LOOP,    PUT,    GET    ;
terminal    THEN,    WHILE,    SKIP,    YIELDS, WHEN    ;

// Special-character terminals, no value attached
terminal    L_PAREN    ,R_PAREN,L_SQUARE, R_SQUARE, L_CURLEY, R_CURLEY    ;
terminal    EQUAL,    GREATER,LESS,    COMMA,  DOT    ;
terminal    PLUS,    MINUS,    TIMES,  DIVIDE    ;

// Terminals returned by the scanner with a value.
terminal String  IDENT    ;
terminal Integer INTCONST    ;
terminal String  TEXTCONST    ;

// Non-terminals that have no value.
// nonterminal xxx

nonterminal program  ;

/**********************************************************

The nonterminals from your grammar go here

***********************************************************/

nonterminal String scope, statements, statement, outputs, output,
                inputs, input, variablenames, variableDecl,
                variable, variablename, bound, generalBound,
                arrayname, functionname, procedurename,
                parametername, parameters, parameter, type,
                arguments, argument, expression, negatable,
                exprLvl1, exprLvl2, exprLvl3, exprLvl4,
                exprLvl5, exprLvl6, exprAtom;

// Non-terminals that have a value.
// nonterminal type  nameList ;

// PLEASE NOTE: your grammar can not use the 'precedence'
// feature of java-cup. The lines below should remain
// commented.
//
//precedence left PLUS, MINUS;
//precedence left TIMES, DIVIDE;        // Higher precedence.

// The grammar section.

// This specifies the initial symbol of the grammar.
start with program;

/* Notice that sometimes the action must be inside the production rule,
 * not after it.  This is a subtle yet significant difference from YACC.
 * This is because the CUP parser is looking ahead one token.  It ALWAYS
 * reads one more token before it will act on the production.
 */

program ::= scope:s {: RESULT = s; :};        // the main program


/*****************************************************************************

  YOUR CAREFULLY CRAFTED GRAMMAR FOR THE CSC488S SOURCE LANGUAGE

    GOES HERE

****************************************************************************/

statements ::= statements:s1 statement:s2
                {: RESULT = s1 + s2 + "\n"; :}
             | statement:s
                {: RESULT = s + "\n"; :}
             ;

statement ::= variable:v LESS EQUAL expression:e
                {: RESULT = v + " <= " + e; :}
            | IF expression:e THEN statements:s END
                {: RESULT = "IF " + e + " THEN\n" + s + "\nEND"; :}
            | IF expression:e THEN statements:s1 ELSE statements:s2 END
                {: RESULT = "IF " + e + " THEN\n" + s1 + "ELSE\n" + s2 + "END"; :}
            | WHILE expression:e DO statements:s END
                {: RESULT = "WHILE " + e + " DO\n" + s + "END"; :}
            | LOOP statements:s END
                {: RESULT = "LOOP\n" + s + "END"; :}
            | EXIT
                {: RESULT = "EXIT"; :}
            | EXIT WHEN expression:e
                {: RESULT = "EXIT WHEN " + e; :}
            | RETURN L_PAREN expression:e R_PAREN
                {: RESULT = "RETURN (" + e + ")"; :}
            | RETURN
                {: RESULT = "RETURN"; :}
            | PUT outputs:o
                {: RESULT = "PUT " + o; :}
            | GET inputs:i
                {: RESULT = "GET " + i; :}
            | procedurename:n
                {: RESULT = n; :}
            | procedurename:n L_PAREN arguments:a R_PAREN
                {: RESULT = n + "(" + a + ")"; :}
            | scope:s
                {: RESULT = s; :}
            | type:t variablenames:n
                {: RESULT = t + " " + n; :}
            | type:t FUNCTION functionname:n scope:s
                {: RESULT = t + " FUNCTION " + n + " " + s; :}
            | type:t FUNCTION functionname:n L_PAREN parameters:p R_PAREN scope:s
                {: RESULT = t + " FUNCTION" + n + "(" + p + ") " + s; :}
            | PROCEDURE procedurename:n scope:s
                {: RESULT = "PROCEDURE" + n + " " + s; :}
            | PROCEDURE procedurename:n L_PAREN parameters:p R_PAREN scope:s
                {: RESULT = "PROCEDURE" + n + "(" + p + ") " + s; :}
            ;

variablenames ::= variablenames:n COMMA variableDecl:d
                    {: RESULT = n + ", " + d; :}
                | variableDecl:d
                    {: RESULT = d; :}
                ;

variableDecl ::= variablename:n
                    {: RESULT = n; :}
               | variablename:n L_SQUARE bound:b R_SQUARE
                    {: RESULT = n + "[" + b + "]"; :}
               | variablename:n L_SQUARE bound:b1 COMMA bound:b2 R_SQUARE
                    {: RESULT = n + "[" + b1 + ", " + b2 + "]"; :}
               ;

bound ::= INTCONST:i
            {: RESULT = i.toString(); :}
        | generalBound:b1 DOT DOT generalBound:b2
            {: RESULT = b1 + ".." + b2; :}
        ;

generalBound ::= INTCONST:i
                    {: RESULT = i.toString(); :}
               | MINUS INTCONST:i
                    {: RESULT = "-" + i.toString(); :}
               ;

scope ::= BEGIN END
            {: RESULT = "BEGIN\nEND"; :}
        | BEGIN statements:s END
            {: RESULT = "BEGIN\n" + s + "END"; :}
        ;

outputs ::= outputs:o1 COMMA output:o2
            {: RESULT = o1 + ", " + o2; :}
          | output:o
            {: RESULT = o; :}
          ;

output ::= expression:e
            {: RESULT = e; :}
         | TEXTCONST:t
            {: RESULT = "\"" + t + "\""; :}
         | SKIP
            {: RESULT = "SKIP"; :}
         ;

inputs ::= inputs:i1 COMMA input:i2
            {: RESULT = i1 + ", " + i2; :}
         | input:i
            {: RESULT = i; :}
         ;

input ::= variable:v
            {: RESULT = v; :}
        ;

type ::= INTEGER
            {: RESULT = "INTEGER"; :}
       | BOOLEAN
            {: RESULT = "BOOLEAN"; :}
       ;

arguments ::= arguments:a1 COMMA argument:a2
                {: RESULT = a1 + ", " + a2; :}
            | argument:a
                {: RESULT = a; :}
            ;

argument ::= expression:e
                {: RESULT = e; :}
           ;

parameters ::= parameters:p1 COMMA parameter:p2
                {: RESULT = p1 + ", " + p2; :}
            | parameter:p
                {: RESULT = p; :}
            ;

parameter ::= type parametername:n
                {: RESULT = n; :}
            ;

variable ::= variablename:v
                {: RESULT = v; :}
           | arrayname:n L_SQUARE expression:e R_SQUARE
                {: RESULT = n + "[" + e + "]"; :}
           | arrayname:n L_SQUARE expression:e1 COMMA expression:e2 R_SQUARE
                {: RESULT = n + "[" + e1 + ", " + e2 + "]"; :}
           ;


// NB: In an expression, IDENT could stand for: variablename, functionname,
// arrayname or parametername, but at this point the parser cannot resolve
// which one (this is left for the semantic processing after the syntax parser).
expression ::= exprLvl6:e
                {: RESULT = e; :}
             ;

exprLvl6 ::= exprLvl6:e1 OR exprLvl5:e2
                 {: RESULT = "(" + e1 + " | " + e2 + ")"; :}
            | exprLvl5:e
                 {: RESULT = e; :}
            ;

exprLvl5 ::= exprLvl5:e1 AND exprLvl4:e2
                {: RESULT = "(" + e1 + " & " + e2 + ")"; :}
           | exprLvl4:e
                {: RESULT = e; :}
           ;

exprLvl4 ::= NOT exprLvl4:e
                {: RESULT = "(!" + e + ")"; :}
           | exprLvl3:e
                {: RESULT = e; :}
           ;

exprLvl3 ::= exprLvl2:e1 EQUAL exprLvl2:e2
                {: RESULT = "(" + e1 + " = " + e2 + ")"; :}
           | exprLvl2:e1 NOT EQUAL exprLvl2:e2
                {: RESULT = "(" + e1 + " != " + e2 + ")"; :}
           | exprLvl2:e1 LESS exprLvl2:e2
                {: RESULT = "(" + e1 + " < " + e2 + ")"; :}
           | exprLvl2:e1 LESS EQUAL exprLvl2:e2
                {: RESULT = "(" + e1 + " <= " + e2 + ")"; :}
           | exprLvl2:e1 GREATER exprLvl2:e2
                {: RESULT = "(" + e1 + " > " + e2 + ")"; :}
           | exprLvl2:e1 GREATER EQUAL exprLvl2:e2
                {: RESULT = "(" + e1 + " >= " + e2 + ")"; :}
           | exprLvl2:e
                {: RESULT = e; :}
           ;

exprLvl2 ::= exprLvl2:e1 PLUS exprLvl1:e2
                {: RESULT = "(" + e1 + " + " + e2 + ")"; :}
           | exprLvl2:e1 MINUS exprLvl1:e2
                {: RESULT = "(" + e1 + " - " + e2 + ")"; :}
           | exprLvl1:e
                {: RESULT = e; :}
           ;

exprLvl1 ::= exprLvl1:e1 TIMES negatable:e2
                {: RESULT = "(" + e1 + " * " + e2 + ")"; :}
           | exprLvl1:e1 DIVIDE negatable:e2
                {: RESULT = "(" + e1 + " / " + e2 + ")"; :}
           | negatable:e
                {: RESULT = e; :}
           ;

negatable ::= MINUS negatable:e
                {: RESULT = "(-" + e + ")"; :}
            | exprAtom:e
                {: RESULT = e; :}
            ;

exprAtom ::= INTCONST:n
                {: RESULT = n.toString(); :}
           | TRUE
                {: RESULT = "TRUE"; :}
           | FALSE
                {: RESULT = "FALSE"; :}
           | IDENT:i
                {: RESULT = i; :}
           | L_PAREN expression:e R_PAREN
                {: RESULT = "(" + e + ")"; :}
           | arrayname:n L_SQUARE expression:e R_SQUARE
                {: RESULT = n + "[" + e + "]"; :}
           | arrayname:n L_SQUARE expression:e1 COMMA expression:e2 R_SQUARE
                {: RESULT = n + "[" + e1 +"," + e2 + "]"; :}
           | functionname:n L_PAREN arguments:a R_PAREN
                {: RESULT = n + "(" + a + ")"; :}
           | L_CURLEY statements:s YIELDS expression:e R_CURLEY
                {: RESULT = "{\n" + s + " YIELDS " + e + "\n}"; :}
           ;

variablename ::= IDENT:i
                    {: RESULT = i; :}
               ;

arrayname ::= IDENT:i
                {: RESULT = i; :}
            ;

functionname ::= IDENT:i
                    {: RESULT = i; :}
               ;

parametername ::= IDENT:i
                    {: RESULT = i; :}
                ;

procedurename ::= IDENT:i
                    {: RESULT = i; :}
                ;
